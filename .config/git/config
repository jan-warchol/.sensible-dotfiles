# Note that old versions of git may not load configuration from ~/.config/git/config,
# loading only ~/.gitconfig.  I _strongly_ recommend installing latest git (>= 2.0)!

[alias]

    # SIMPLE "SHORTCUT" ALIASES

    ap = add --patch   # interactively select hunks to add, very useful
    au = add --update   # stage only tracked files - usually you want this rather than --all

    b = branch
    bv = branch --verbose --verbose   # lists branches with SHAs and upstreams

    c = checkout
    co = checkout   # I prefer 'c', but many people are used to 'co'

    k = commit   # no git command starts with 'k', and 'k' matches pronunciation!
    ci = commit   # I prefer 'k', but many people are used to 'ci'
    kma = commit --all -m   # 'kma' instead of 'kam' because it's easier to type

    d = diff --color=always   # force coloring for use with less -R
    wd = diff --color=always --word-diff=color   # mnemonic: Word-Diff

    g = grep --color=always --line-number
    gh5 = grep --color=always --heading --context 5

    l = log --color=always --decorate   # force coloring for use with less -R

    rb = rebase
    rbo = rebase --onto   # quite useful, see examples in 'git help rebase'
    rbi = rebase --interactive

    rs = reset
    rs1 = reset HEAD~1

    s = status --short   # I prefer terse output.  See also --branch option.
    st = status



    # MORE SOPHISTICATED ALIASES

    # "smart amend"
    #
    # Fixup a specified commit and use rebase to merge the fixup (like commit --amend,
    # but for commits before the currently checked-out one - see the description of
    # --fixup option in `git commit` manpage).  By default the fixup will incorporate
    # staged changes, but you can also use `-a` option (or specify paths), like with
    # `git commit` itself.
    # Don't use this if there was a merge after the commit to be amended.
    #
    fix = "!sh -c 'set -e; \
        commit_id=$(git rev-parse $1); \
        shift; \
        git commit --fixup $commit_id $@; \
        if ! git diff --quiet HEAD; then \
            dirtytree=1; \
            echo \"Stashing your other changes...\"; \
            git stash save \"Stashed before amending $commit_id\"; \
        fi; \
        git rebase --interactive --autosquash $commit_id~; \
        if [ -n \"$dirtytree\" ]; then \
            git stash pop; \
        fi' -"

    # trash - discard changes
    #
    # Use this command instead of `reset --hard`, as it makes it possible to undo
    # the trashing.  Right now this is implemented simply by using `stash` command,
    # so to bring back discarded changes you just do `git stash pop <stash>`.
    #
    # Useful options:
    #     -p    select which hunks to discard
    #     -u    also remove untracked files
    #     -a    also remove untracked and ignored files
    #
    # TODO:
    # - add support for trashing changes in indvidual files
    # - rewrite this as a standalone git command
    # - send a patch upstream?
    #
    trash = !sh -c 'git stash save "$@" "changes trashed on $(date +\"%Y-%m-%d %H:%M\")"' -



[color]
    ui = auto

[core]
    # display non-ASCII characters (e.g. Polish) instead of quoting them:
    quotepath = false

[diff]
    # detect renamed files and output only actual differences between versions
    renames = copies

[merge]
    # in case of merge conflict also show common ancestor version
    conflictstyle = diff3

[push]
    default = simple

[rebase]
    # automatically process fixup! commits when rebasing interactively
    autosquash = true
